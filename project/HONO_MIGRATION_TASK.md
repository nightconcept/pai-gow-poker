# Pai Gow Poker - Task List (FASTIFY_MIGRATION_TASK.md)

**Purpose:** Tracks the tasks required to migrate the backend from the current Node.js/`ws` implementation to Fastify, leveraging `@fastify/websocket`. This includes active work, sub-tasks, milestones, backlog items, and discoveries made mid-process.

**Includes:**
- Bullet list of active work for the Fastify migration.
- Milestones specific to the migration.
- Backlog items (potentially relevant post-migration).
- Mid-Process Discoveries section.

**Prompt to AI:** Can be used to update status or add tasks. Examples:
- *"Update TASK.md to mark 'Backend: Install Fastify & Dependencies' as done [x]."*
- *"Update TASK.md to add a new task under 'Refactor Core Logic': '[ ] Backend (AI): Refactor deck shuffling logic into a separate utility function'."*
- *(Global Rule Implied):* When a task marked (AI) is completed via generation/integration, prompt to update the TASK.md.

**Legend:**
- `[ ]` To Do
- `[x]` Done
- **(Human):** Task best performed manually due to configuration, architectural decisions, or complex review needs.
- **(AI):** Task suitable for AI code generation assistance. *Note: Expect code generated by Gemini 2.5 Flash may require significant human review, debugging, and refinement, especially for state management integration and complex asynchronous logic.*

---

## Phase: Backend Migration to Fastify

These tasks focus on replacing the existing Node.js `ws` server with a Fastify application handling WebSocket connections. The goal is to retain all existing MVP functionality.

### Migration Sub-Phase 1: Setup & Basic Server

1.  **[ ] Backend (Human): Install Fastify & Dependencies**
    * Navigate to `apps/backend`.
    * Run `pnpm add fastify @fastify/websocket`.
    * Optionally, review if the direct `ws` dependency can be removed (likely yes, as `@fastify/websocket` uses it internally). Update `package.json` accordingly.
    * Run `pnpm install` from the root directory.
    * **Verify:** Dependencies are listed in `apps/backend/package.json` and installed in `node_modules`.

2.  **[ ] Backend (AI/Human): Initialize Basic Fastify Server**
    * **(AI):** Generate the initial structure for `apps/backend/src/index.ts` (or rename existing entry point). This should:
        * Import `fastify`.
        * Import `@fastify/websocket`.
        * Create a Fastify instance (e.g., `const server = fastify({ logger: true })`). Add basic options like logging.
        * Register the `@fastify/websocket` plugin (e.g., `server.register(fastifyWebsocket)`).
        * Define a basic async `start` function that calls `server.listen({ port: <PORT>, host: '0.0.0.0' })`. Ensure the port is configurable (e.g., via environment variable or config file, defaulting to the previous port, e.g., 8080).
        * Call the `start` function.
    * **(Human):** Review the generated code. Ensure correct imports, registration, and server start logic. Define the port configuration strategy.
    * **Verify:** Run the backend (`pnpm --filter backend dev` or similar). Verify the Fastify server starts and logs initialization messages without errors.

3.  **[ ] Backend (AI/Human): Set up WebSocket Route**
    * **(AI):** Generate the code within `index.ts` to define a WebSocket route handler, typically using `server.get('/ws', { websocket: true }, (connection /* { socket, request } */, req /* FastifyRequest */) => { ... })`.
        * Include basic logging inside the handler to indicate a connection attempt (`connection established`).
        * Add basic `connection.socket.on('message', message => { ... })` and `connection.socket.on('close', () => { ... })` handlers *inside* the main route handler, with simple logging for now.
    * **(Human):** Review the generated route structure. Ensure the handler function signature is correct for `@fastify/websocket`. Placeholders for future logic should be clear.
    * **Verify:** Restart the backend. Connect using a simple WebSocket client (like the existing frontend or a tool like Postman WebSocket tab) to `ws://<your-backend-host>:<PORT>/ws`. Verify the "connection established" log appears on the server. Verify message/close logs appear when sending test messages or disconnecting.

### Migration Sub-Phase 2: Integrate State & Connection Management

4.  **[ ] Backend (Human): Prepare State Management for Fastify Context**
    * Review the existing in-memory state management code (likely the `GameTable` class/object and `Player` class/object instances).
    * Decide on the strategy to make the *single* `GameTable` instance accessible within the `/ws` route handler for *all* connections. Options:
        * Instantiate `GameTable` globally (simplest for single-table MVP).
        * Use Fastify decorators (`server.decorate`) to attach the instance to the server or request objects (more scalable for future).
    * Implement the chosen strategy. For MVP, instantiating globally might be sufficient.
    * **Verify:** Ensure the `GameTable` instance can be accessed within the `/ws` route handler's scope (e.g., log `gameTable.players.length`).

5.  **[ ] Backend (AI/Human): Refactor Connection/Disconnection Logic**
    * **(AI):** Adapt the *existing* logic from the old `ws.on('connection')` handler:
        * Inside the Fastify `/ws` handler: Add a new `Player` object to the `gameTable.players` array. Associate the `connection.socket` with this `Player` object (e.g., add `socket` property to `Player`, or maintain a separate map like `Map<WebSocket, Player>`).
    * **(AI):** Adapt the *existing* logic from the old `socket.on('close')` handler:
        * Inside the `connection.socket.on('close', () => { ... })` handler within the Fastify `/ws` route: Find the corresponding `Player` object using the closed socket, remove the `Player` from `gameTable.players`, and potentially broadcast a 'playerLeft' message (logic to be fully refactored later).
    * **(Human):** Review the generated code carefully. Ensure correct state manipulation (adding/removing players). Pay close attention to how the `Player` is identified upon disconnection (using the socket instance). Ensure the `connection.socket` object is the raw `ws` socket compatible with previous logic if needed.
    * **Verify:** Connect multiple clients. Check server logs/state to confirm Players are added to `gameTable.players` correctly. Disconnect clients; verify corresponding Players are removed.

### Migration Sub-Phase 3: Refactor Core Logic

6.  **[ ] Backend (AI/Human): Refactor Message Handling Logic**
    * **(AI):** Move the main message processing logic (likely a `switch` statement or `if/else` block based on `message.type`) from the old global `socket.on('message')` handler *into* the `connection.socket.on('message', message => { ... })` handler within the Fastify `/ws` route.
        * Ensure the incoming `message` is parsed correctly (assuming `Buffer` -> `JSON.parse`).
        * Ensure the logic within each case (`setUsername`, `placeBet`, `setPlayerHand`, etc.) correctly identifies the `Player` associated with the `connection.socket` sending the message.
        * Ensure calls to game logic methods use the shared `gameTable` instance.
    * **(Human):** Review this critical refactoring step extensively. Debugging will likely be needed. Ensure the correct `Player` context is maintained for each message. Verify error handling for invalid messages or actions. Check asynchronous operations if any exist in the handlers.
    * **Verify:** Test *each* message type (`setUsername`, `placeBet`, `setPlayerHand`) sent from the frontend. Verify the backend processes them correctly, updates the `gameTable` state, and sends appropriate responses/broadcasts (broadcasting refinement in next step).

7.  **[ ] Backend (AI/Human): Refactor Broadcasting Logic**
    * **(AI):** Adapt the existing broadcasting logic. Instead of iterating over `wss.clients` (from the old `ws` server), iterate over the sockets associated with the `Player` objects currently in the `gameTable.players` array.
        * Identify where messages need to be sent to *all* players in the table (e.g., `gameStateUpdate`, `playerJoined`, `roundResult`). Implement a helper function like `broadcast(messageObject)` that iterates through `gameTable.players`, accesses their associated sockets, and sends the stringified `messageObject`.
        * Identify where messages need to be sent to a *specific* player (e.g., `usernameSuccess`, `dealHand`). Ensure the correct player's socket is retrieved and used.
    * **(Human):** Review the broadcasting implementation. Ensure correct iteration and socket access. Handle potential errors during sending (e.g., socket closed unexpectedly). Ensure filtering (e.g., not sending a message back to the originator if needed) is correctly implemented.
    * **Verify:** Play through a full game round. Verify that all players receive the necessary broadcast messages (player join/leave, state changes, dealer hands, results). Verify individual players receive messages directed only at them (their hand, username success/failure).

### Migration Sub-Phase 4: Infrastructure & Testing

8.  **[ ] Backend (Human): Update Dockerfile**
    * Modify the `apps/backend/Dockerfile`.
    * Change the `CMD` or `ENTRYPOINT` to execute the new Fastify server entry point (e.g., `CMD ["node", "dist/index.js"]` if using TypeScript compilation, or `CMD ["node", "src/index.js"]` if running JS directly).
    * Ensure the `EXPOSE` instruction matches the port Fastify is configured to listen on.
    * Review other layers (dependency installation, code copying) â€“ they might be okay but double-check paths.
    * **Verify:** Build the Docker image using the updated Dockerfile (`docker build ...`). Ensure it builds successfully.

9.  **[ ] Backend (Human): Test Full MVP Functionality**
    * Run the new Fastify backend (ideally within the Docker container locally or via Cloudflare Tunnel).
    * Connect multiple frontend clients (via Vercel deployment).
    * Thoroughly test all features covered by the original MVP task list (Tasks 1-20):
        * Username setting (uniqueness)
        * Betting
        * Dealing (Player hands, Dealer face-up)
        * Dealer House Way & Ace-High Push logic/display
        * Player hand setting UI interaction & validation
        * Hand comparison & outcome determination (Win/Loss/Push - commission-free)
        * DB Balance updates
        * Game state progression display
        * Player join/leave notifications
    * Test edge cases (running out of DB, invalid hand setting attempts).
    * **Verify:** The application behaves identically to the pre-migration version from the user's perspective. All MVP features work correctly with the Fastify backend.

---

## Milestones (Migration)

-   **[ ] M-M1: Fastify Setup Complete:** Tasks 1-3 finished. Basic Fastify server runs and accepts WebSocket connections.
-   **[ ] M-M2: State & Connection Integrated:** Tasks 4-5 finished. Backend manages player connections and associates them with the game state within the Fastify context.
-   **[ ] M-M3: Core Logic Refactored:** Tasks 6-7 finished. All message handling and broadcasting logic operates correctly within Fastify.
-   **[ ] M-M4: Migration Tested & Deployed:** Tasks 8-9 finished. The Fastify backend is containerized and fully tested, replacing the old implementation.

---

## Enhancements (Post-Migration Backlog)

*(These are items from the original backlog or new ideas, relevant after the migration)*

-   [ ] Infrastructure: Automate Backend Deployment (GitHub Actions for Fastify/Docker).
-   [ ] Backend: Implement Multiple Table Support (Refactor state management).
-   [ ] Backend: Implement Game Variant Selection logic.
-   [ ] Backend: Implement Host Controls logic.
-   [ ] Backend: Implement Save/Load Game State (JSON or DB).
-   [ ] Backend: Implement Variable Betting & Side Bets.
-   [ ] Backend: Add Database Integration (replace in-memory state).
-   [ ] Backend: Add User Accounts (persistent).
-   [ ] Backend: Add Unit/Integration Tests for Fastify routes and game logic.
-   [ ] Backend: Add Robust Logging & Error Handling within Fastify.
-   [ ] Frontend/Backend: Implement Text Chat feature via WebSockets.
-   [ ] Frontend: Add Card Graphics (Images/SVG).
-   [ ] Frontend: Add Dark Mode Toggle (Issue #9).
-   [ ] Frontend: Cleanup static buttons (Issue #10).
-   [ ] Frontend: Player ready state indicators (Issue #13).
-   [ ] Backend: Add graceful recovery from error states (Issue #16).
-   ... *(Other original backlog items)* ...

---

## Mid-Process Discoveries / Notes (Migration)

-   *(Note)* Decision: Will instantiate `GameTable` globally for the MVP migration simplicity. Will add a TODO to refactor using decorators if multi-table support is added later.
-   *(Note)* `@fastify/websocket` uses the `ws` library internally, so direct `ws` dependency likely removable.
-   *(Potential Issue)* Need to confirm how binary data (if any, though likely all JSON) is handled by `@fastify/websocket` message events compared to raw `ws`. Assume text/JSON for now.
-   *(Note)* Fastify's request lifecycle hooks are not directly applicable to WebSocket messages but could be used for the initial HTTP upgrade request if needed for auth/setup later.